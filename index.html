<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script type="text/javascript" src="anime.min.js"></script>
		<script type="module">
			import { PointerLockControls } from './PointerLockControls.js';
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			const renderer = new THREE.WebGLRenderer();
			const controls = new PointerLockControls( camera, document.body );
			renderer.setSize(window.innerWidth, window.innerHeight);

			var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
			scene.add(directionalLight);

			var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
			directionalLight.position.z = 10;
			directionalLight.position.x = 10;
			scene.add(directionalLight);

			// THIS IS WHERE WE ADDING OUR CANVAS
			document.body.appendChild(renderer.domElement);

			const resizeCanvas = () => {
			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();
			    renderer.setSize(window.innerWidth, window.innerHeight);
			};

			const createCube = (geometry, material, position) => {
				const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
				const {x, y, z} = position;
				cubeMesh.position.set(x, y, z);

				const edgesOfCube = new THREE.EdgesGeometry( cubeGeometry );
				const line = new THREE.LineSegments( edgesOfCube, new THREE.LineBasicMaterial({ color: 0xF2F2F2 }));
				cubeMesh.add(line);
				return cubeMesh;
			};

			const createText = () => {
				var loader = new THREE.FontLoader();
				loader.load('fonts/Baloo_2_Regular.json', function ( font ) {
					var geometry = new THREE.TextGeometry( 'This is my first cube!', {
						font: font,
						size: 2,
						height: 0,
					} );

					var textMaterial = new THREE.MeshBasicMaterial( { color: 0xCDBB7A } );

				    var mesh = new THREE.Mesh( geometry, textMaterial );
				    mesh.position.set( -13, 5, -20 );

				    scene.add( mesh );
				} );
			};

			const createStars = () => {
				const starGeo = new THREE.Geometry();
		      	for(let i=0;i<10000;i++) {
		        	const star = new THREE.Vector3(
		          		anime.random(-1500, 1500),
		          		anime.random(-1500, 1500),
		          		anime.random(-1500, 1500),
		        	);
		        	starGeo.vertices.push(star);
		      	};

		      const sprite = new THREE.TextureLoader().load( 'star.png' );
		      const starMaterial = new THREE.PointsMaterial({
		        color: 0xaaaaaa,
		        size: 2.5,
		        map: sprite
		      });

		      const stars = new THREE.Points(starGeo,starMaterial);
		      return stars;
			};

			const createHeart = () => {
				const shape = new THREE.Shape();
				const x = -2.5;
				const y = -5;
				shape.moveTo(x + 2.5, y + 2.5);
				shape.bezierCurveTo(x + 2.5, y + 2.5, x + 2, y, x, y);
				shape.bezierCurveTo(x - 3, y, x - 3, y + 3.5, x - 3, y + 3.5);
				shape.bezierCurveTo(x - 3, y + 5.5, x - 1.5, y + 7.7, x + 2.5, y + 9.5);
				shape.bezierCurveTo(x + 6, y + 7.7, x + 8, y + 4.5, x + 8, y + 3.5);
				shape.bezierCurveTo(x + 8, y + 3.5, x + 8, y, x + 5, y);
				shape.bezierCurveTo(x + 3.5, y, x + 2.5, y + 2.5, x + 2.5, y + 2.5);

				const extrudeSettings = {
					steps: 10,  
					depth:  2.5,  
					bevelEnabled: true,  
					bevelThickness: 0.10,  
					bevelSize: 0.10,  
					bevelSegments: 0,  
				};

				const geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
				const meshMaterial = new THREE.MeshStandardMaterial( { color: 0xFF3299 } );
				const mesh = new THREE.Mesh( geometry, meshMaterial );
				mesh.position.set( 0, 0, -20 );
				return mesh;
			};

			// const cubeGeometry = new THREE.BoxGeometry(5,5,5);
			// const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x10425C });
			// const cube = createCube(cubeGeometry, cubeMaterial, { x: 0, y: -3, z: -20 });
			const stars = createStars();
			const heart = createHeart();
			// createText();
			createHeart();
			var cameraLookAtX = 0;
			var cameraLookAtY = 0;
			var cameraLookingDirection = true;

			const rotateCube = (cube) => {
				cube.rotation.x += 0.02;
				cube.rotation.y += 0.02;
			};

			var pressedKeys = {};
			var camRotation = 0;
			var mouseDown = false;
			var mouseX, mouseY;
			var onClickPositionX, onClickPositionY;
			var topVal = 0;

				const moveCamera = () => {
					if (controls.isLocked) {
						let speed = 0.5;
						if (pressedKeys[16]) {
							speed = 3;
						}
					if (pressedKeys[87]) {
						camera.translateZ(-speed);
					} 
					if (pressedKeys[83]){
						camera.translateZ(speed);
					}
					if (pressedKeys[68]){
						camera.translateX(speed);
					}
					if (pressedKeys[65]){
						camera.translateX(-speed);
					}
					if (pressedKeys[81]) {
						camera.translateY(speed);
					}
					if (pressedKeys[69]) {
						camera.translateY(-speed);
					}
					}
				}

			window.addEventListener("keydown", (event) => {
				pressedKeys[event.keyCode] = true;
			}, true); 

			window.addEventListener("keyup", () => {
				pressedKeys[event.keyCode] = false;
			}, true);

			window.addEventListener('mousedown', () => {
				controls.lock();
			})

			// window.addEventListener('mousemove', function(event) {
			//     mouseX = event.clientX;
			//     mouseY = event.clientY;
			//     if (mouseDown){
			//     	cameraLookAtX = (onClickPositionX - mouseX);
			//     	if (cameraLookAtX < 0){
			//     		if (cameraLookAtX <= topVal ) {
			//     			topVal = cameraLookAtX;
			//     		}else{
			//     			topVal = 0;
			//     			onClickPositionX = event.clientX;
			//     			camRotation = 0;

			//     			return;
			//     		}
			//     	}else {
			//     		if (cameraLookAtX >= topVal ) {
			//     			topVal = cameraLookAtX;
			//     		}else{
			//     			topVal = 0;
			//     			onClickPositionX = event.clientX;
			//     			camRotation = 0;
			//     			return;
			//     		}
			//     	}
			//     	camRotation = cameraLookAtX;
			//     	cameraLookAtY = (onClickPositionY - mouseY);
			//     	camera.rotation.y += cameraLookAtX / 10000;
			//     	// console.log(camera.rotation.y);
			//     	// camera.rotateY(cameraLookAtX / 10000);
			//     	// camera.lookAt(0, cameraLookAtY++, 0);
			//     	// camera.rotateX(cameraLookAtX / 1000);
			//     	// camera.rotateZ(0);
			//     }else {
			//     	camRotation = 0;
			//     }
			// }, false);

			// window.addEventListener("mousedown", function(event) {
			//     mouseDown = true;
			//     onClickPositionX = event.clientX;
			//     onClickPositionY = event.clientY;
			//     camRotation = 0;
			// }, false);

			// window.addEventListener("mouseup", function(event) {
			//     mouseDown = false;
			//     onClickPositionX = 0;
			//     onClickPositionY = 0;
			//     camRotation = 0;
			//     topVal = 0;
			// }, false);

			window.addEventListener('resize', resizeCanvas, false);

			scene.add(stars);
		  scene.add(heart);
			scene.add(controls.getObject());

			function animate(time){
				requestAnimationFrame(animate);
				rotateCube(heart);
				moveCamera();
				renderer.render(scene, camera);
			};
			requestAnimationFrame(animate);
		</script>
	</body>
</html>
