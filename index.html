<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
<!-- 		<script src="orbitControls.js"></script>
		<script src="pointerLockControl.js"></script> -->
		<script type="text/javascript" src="anime.min.js"></script>
		<script>
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);

			// THIS IS WHERE WE ADDING OUR CANVAS
			document.body.appendChild( renderer.domElement );

			const createCube = (geometry, material, position) => {
				const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
				const {x, y, z} = position;
				cubeMesh.position.set(x, y, z);

				const edgesOfCube = new THREE.EdgesGeometry( cubeGeometry );
				const line = new THREE.LineSegments( edgesOfCube, new THREE.LineBasicMaterial({ color: 0xF2F2F2 }));
				cubeMesh.add(line);
				return cubeMesh;
			};

			const createText = () => {
				var loader = new THREE.FontLoader();
				loader.load('fonts/Baloo_2_Regular.json', function ( font ) {
					var geometry = new THREE.TextGeometry( 'This is my first cube!', {
						font: font,
						size: 2,
						height: 0,
					} );
					var textMaterial = new THREE.MeshBasicMaterial( { color: 0xCDBB7A } );

				    var mesh = new THREE.Mesh( geometry, textMaterial );
				    mesh.position.set( -13, 5, -20 );

				    scene.add( mesh );
				} );
			};

			const createStars = () => {
				const starGeo = new THREE.Geometry();
		      	for(let i=0;i<10000;i++) {
		        	const star = new THREE.Vector3(
		          		anime.random(-1500, 1500),
		          		anime.random(-1500, 1500),
		          		anime.random(-1500, 1500),
		        	);
		        	starGeo.vertices.push(star);
		      	};

		      const sprite = new THREE.TextureLoader().load( 'star.png' );
		      const starMaterial = new THREE.PointsMaterial({
		        color: 0xaaaaaa,
		        size: 2.5,
		        map: sprite
		      });

		      const stars = new THREE.Points(starGeo,starMaterial);
		      return stars;
			};


			const cubeGeometry = new THREE.BoxGeometry(5,5,5);
			const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x10425C });
			const cube = createCube(cubeGeometry, cubeMaterial, { x: 0, y: -3, z: -20 });
			const stars = createStars();

			createText();

			var cameraLookAtX = 0;
			var cameraLookAtY = 0;
			var cameraLookingDirection = true;

			const rotateCube = (cube) => {
				cube.rotation.x += 0.02;
				cube.rotation.y += 0.02;
			};

			var pressedKeys = {};
			var camRotation = 0;
			var mouseDown = false;
			var mouseX, mouseY;
			var onClickPositionX, onClickPositionY;
			var topVal = 0;

		      const moveCamera = () => {
		      	let speed = 0.5;
		      	if (pressedKeys[16]) {
		      		speed = 3;
		      	}
		     	if (pressedKeys[87]) {
		     		camera.translateZ(-speed);
		     	} 
		     	if (pressedKeys[83]){
		     		camera.translateZ(speed);
		     	}
		     	if (pressedKeys[68]){
		     		camera.translateX(speed);
		     	}
		     	if (pressedKeys[65]){
		     		camera.translateX(-speed);
		     	}
		      }

		    document.addEventListener("keydown", (event) => {
				pressedKeys[event.keyCode] = true;
			}, true); 

			document.addEventListener("keyup", () => {
				pressedKeys[event.keyCode] = false;
			}, true);

			document.addEventListener('mousemove', function(event) {
			    mouseX = event.clientX;
			    mouseY = event.clientY;
			    if (mouseDown){
			    	cameraLookAtX = (onClickPositionX - mouseX);
			    	if (cameraLookAtX < 0){
			    		if (cameraLookAtX <= topVal ) {
			    			topVal = cameraLookAtX;
			    		}else{
			    			topVal = 0;
			    			onClickPositionX = event.clientX;
			    			camRotation = 0;

			    			return;
			    		}
			    	}else {
			    		if (cameraLookAtX >= topVal ) {
			    			topVal = cameraLookAtX;
			    		}else{
			    			topVal = 0;
			    			onClickPositionX = event.clientX;
			    			camRotation = 0;
			    			return;
			    		}
			    	}
			    	camRotation = cameraLookAtX;
			    	cameraLookAtY = (onClickPositionY - mouseY);
			    	camera.rotation.y += cameraLookAtX / 10000;
			    	// console.log(camera.rotation.y);
			    	// camera.rotateY(cameraLookAtX / 10000);
			    	// camera.lookAt(0, cameraLookAtY++, 0);
			    	// camera.rotateX(cameraLookAtX / 1000);
			    	// camera.rotateZ(0);
			    }else {
			    	camRotation = 0;
			    }
			}, false);

			document.body.addEventListener("mousedown", function(event) {
			    mouseDown = true;
			    onClickPositionX = event.clientX;
			    onClickPositionY = event.clientY;
			    camRotation = 0;

			}, false);
			document.body.addEventListener("mouseup", function(event) {
			    mouseDown = false;
			    onClickPositionX = 0;
			    onClickPositionY = 0;
			    camRotation = 0;
			    topVal = 0;
			}, false);


		    scene.add(stars);
		    scene.add(cube);

			function animate(time){
				requestAnimationFrame(animate);
				rotateCube(cube);
				moveCamera();
				renderer.render(scene, camera);
			};
			requestAnimationFrame(animate);
		</script>
	</body>
</html>
