<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<link rel="shortcut icon" href="#">
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script type="text/javascript" src="anime.min.js"></script>
		<script type="module">
			import { PointerLockControls } from './PointerLockControls.js';
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			const renderer = new THREE.WebGLRenderer();
			const controls = new PointerLockControls( camera, document.body );
			renderer.setSize(window.innerWidth, window.innerHeight);

			const directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
			scene.add(directionalLight);

			const directionalLight2 = new THREE.DirectionalLight( 0xffffff, 0.5 );
			directionalLight.position.z = 10;
			directionalLight.position.x = 10;
			scene.add(directionalLight2);

			// THIS IS WHERE WE ADDING OUR CANVAS
			document.body.appendChild(renderer.domElement);

			const setGradient = (geometry, axis, reverse) => {
				const colors = [{
					stop: 0,
					color: new THREE.Color(0xf7b000)
				}, {
					stop: .25,
					color: new THREE.Color(0xdd0080)
				}, {
					stop: .5,
					color: new THREE.Color(0x622b85)
				}, {
					stop: .75,
					color: new THREE.Color(0x007dae)
				}, {
					stop: 1,
					color: new THREE.Color(0x77c8db)
				}];
				geometry.computeBoundingBox();

				const bbox = geometry.boundingBox;
				const size = new THREE.Vector3().subVectors(bbox.max, bbox.min);

				const vertexIndices = ['a', 'b', 'c'];
				const normalized = new THREE.Vector3();
				let face, vertex, normalizedAxis = 0;

				for (let c = 0; c < colors.length - 1; c++) {

					const colorDiff = colors[c + 1].stop - colors[c].stop;

					for (let i = 0; i < geometry.faces.length; i++) {
						face = geometry.faces[i];
						for (let v = 0; v < 3; v++) {
							vertex = geometry.vertices[face[vertexIndices[v]]];
							normalizedAxis = normalized.subVectors(vertex, bbox.min).divide(size)[axis];
							if (reverse) {
								normalizedAxis = 1 - normalizedAxis;
							}
							if (normalizedAxis >= colors[c].stop && normalizedAxis <= colors[c + 1].stop) {
								const localNormalizedAxis = (normalizedAxis - colors[c].stop) / colorDiff;
								face.vertexColors[v] = colors[c].color.clone().lerp(colors[c + 1].color, localNormalizedAxis);
							}
						}
					}
				}
			};

			const resizeCanvas = () => {
			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();
			    renderer.setSize(window.innerWidth, window.innerHeight);
			};

			const createCube = ({
				geometry = new THREE.BoxGeometry(5,5,5),
				material = new THREE.MeshBasicMaterial({ color: 0x10425C }),
				position = { x: 0, y: -3, z: -20 }
			}) => {
				const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
				const {x, y, z} = position;
				cubeMesh.position.set(x, y, z);

				const edgesOfCube = new THREE.EdgesGeometry( cubeGeometry );
				const line = new THREE.LineSegments( edgesOfCube, new THREE.LineBasicMaterial({ color: 0xF2F2F2 }));
				cubeMesh.add(line);
				return cubeMesh;
			};

			const createText = () => {
				var loader = new THREE.FontLoader();
				loader.load('fonts/Baloo_2_Regular.json', function ( font ) {
					var geometry = new THREE.TextGeometry( 'This is my first cube!', {
						font: font,
						size: 2,
						height: 0,
					} );

					var textMaterial = new THREE.MeshBasicMaterial( { color: 0xCDBB7A } );

				    var mesh = new THREE.Mesh( geometry, textMaterial );
				    mesh.position.set( -13, 5, -20 );

				    scene.add( mesh );
				} );
			};

			const createStars = () => {
				const starGeo = new THREE.Geometry();
		      	for(let i=0;i<10000;i++) {
		        	const star = new THREE.Vector3(
		          		anime.random(-1500, 1500),
		          		anime.random(-1500, 1500),
		          		anime.random(-1500, 1500),
		        	);
		        	starGeo.vertices.push(star);
		      	};

		      const sprite = new THREE.TextureLoader().load( 'star.png' );
		      const starMaterial = new THREE.PointsMaterial({
		        color: 0xaaaaaa,
		        size: 2.5,
		        map: sprite
		      });

		      const stars = new THREE.Points(starGeo,starMaterial);
		      return stars;
			};

			const createHeart = () => {
				const shape = new THREE.Shape();
				const x = -2.5;
				const y = -5;
				shape.moveTo(x + 2.5, y + 2.5);
				shape.bezierCurveTo(x + 2.5, y + 2.5, x + 2, y, x, y);
				shape.bezierCurveTo(x - 3, y, x - 3, y + 3.5, x - 3, y + 3.5);
				shape.bezierCurveTo(x - 3, y + 5.5, x - 1.5, y + 7.7, x + 2.5, y + 9.5);
				shape.bezierCurveTo(x + 6, y + 7.7, x + 8, y + 4.5, x + 8, y + 3.5);
				shape.bezierCurveTo(x + 8, y + 3.5, x + 8, y, x + 5, y);
				shape.bezierCurveTo(x + 3.5, y, x + 2.5, y + 2.5, x + 2.5, y + 2.5);

				const extrudeSettings = {
					steps: 2,
					depth: 2,
					bevelEnabled: true,
					bevelThickness: 1,
					bevelSize: 1,
					bevelSegments: 2, 
				};

				const geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
				const meshMaterial = new THREE.MeshPhongMaterial( { color: 0xFF3299 } );
				const mesh = new THREE.Mesh( geometry, meshMaterial );
				mesh.position.set( 0, 0, -30 );
				return mesh;
			};

			const createTorusKnot = () => {
				const geometry = new THREE.TorusKnotGeometry(2.5, .5, 100, 16);
				const material = new THREE.MeshBasicMaterial({
					vertexColors: THREE.VertexColors,
					wireframe: true
				});
				var mesh = new THREE.Mesh(geometry, material);
				mesh.position.set(0, 0, -15);
				setGradient(geometry, 'z', true);
				return mesh;
			};

			const rotateObject = (object) => {
				object.rotation.x += 0.02;
				object.rotation.y += 0.02;
			};

			const moveCamera = () => {
					if (controls.isLocked) {
						let speed = 0.5;
						if (pressedKeys[16]) {
							speed = 3;
						}
					if (pressedKeys[87]) {
						camera.translateZ(-speed);
					} 
					if (pressedKeys[83]){
						camera.translateZ(speed);
					}
					if (pressedKeys[68]){
						camera.translateX(speed);
					}
					if (pressedKeys[65]){
						camera.translateX(-speed);
					}
					if (pressedKeys[81]) {
						camera.translateY(speed);
					}
					if (pressedKeys[69]) {
						camera.translateY(-speed);
					}
					}
				}

			const pressedKeys = {};

			window.addEventListener("keydown", (event) => {
				pressedKeys[event.keyCode] = true;
			}, true); 

			window.addEventListener("keyup", () => {
				pressedKeys[event.keyCode] = false;
			}, true);

			window.addEventListener('mousedown', () => controls.lock());

			window.addEventListener('resize', resizeCanvas, false);

			const stars = createStars();
			const heart = createHeart();
			const torus = createTorusKnot();

			scene.add(stars);
		  scene.add(torus);
			scene.add(controls.getObject());

			function animate(time){
				requestAnimationFrame(animate);
				rotateObject(torus);
				moveCamera();
				renderer.render(scene, camera);
			};
			requestAnimationFrame(animate);
		</script>
		<script>

			//#region custom mouse move functions

			// var cameraLookAtX = 0;
			// var cameraLookAtY = 0;
			// var cameraLookingDirection = true;
			// var camRotation = 0;
			// var mouseDown = false;
			// var mouseX, mouseY;
			// var onClickPositionX, onClickPositionY;
			// var topVal = 0;
			// window.addEventListener('mousemove', function(event) {
			//     mouseX = event.clientX;
			//     mouseY = event.clientY;
			//     if (mouseDown){
			//     	cameraLookAtX = (onClickPositionX - mouseX);
			//     	if (cameraLookAtX < 0){
			//     		if (cameraLookAtX <= topVal ) {
			//     			topVal = cameraLookAtX;
			//     		}else{
			//     			topVal = 0;
			//     			onClickPositionX = event.clientX;
			//     			camRotation = 0;

			//     			return;
			//     		}
			//     	}else {
			//     		if (cameraLookAtX >= topVal ) {
			//     			topVal = cameraLookAtX;
			//     		}else{
			//     			topVal = 0;
			//     			onClickPositionX = event.clientX;
			//     			camRotation = 0;
			//     			return;
			//     		}
			//     	}
			//     	camRotation = cameraLookAtX;
			//     	cameraLookAtY = (onClickPositionY - mouseY);
			//     	camera.rotation.y += cameraLookAtX / 10000;
			//     	// console.log(camera.rotation.y);
			//     	// camera.rotateY(cameraLookAtX / 10000);
			//     	// camera.lookAt(0, cameraLookAtY++, 0);
			//     	// camera.rotateX(cameraLookAtX / 1000);
			//     	// camera.rotateZ(0);
			//     }else {
			//     	camRotation = 0;
			//     }
			// }, false);

			// window.addEventListener("mousedown", function(event) {
			//     mouseDown = true;
			//     onClickPositionX = event.clientX;
			//     onClickPositionY = event.clientY;
			//     camRotation = 0;
			// }, false);

			// window.addEventListener("mouseup", function(event) {
			//     mouseDown = false;
			//     onClickPositionX = 0;
			//     onClickPositionY = 0;
			//     camRotation = 0;
			//     topVal = 0;
			// }, false);
			// #endregion
			
		</script>
	</body>
</html>
